# 1.0.3
* Adding imports for all the data types used in the generated files, so that instead of the full qualified name of the class, the simple name can be used.
* Adding support for `ENUM` classes

# 1.0.2
* Now if you provide a `companion object` to the abstract class or interface definition, the processor will generate extension methods rather than creating a new class for getting the route. Below example demonstrates how the `getDestination` method will look with and without giving a `companion object`. This will improve navigation as the user can jump directly to the interface/abstract class definition to find the contract of the compose destination
```
@ComposeDestination
interface UserPage {
    val userId: String
    val isLoggedIn: Boolean
    val userIds: IntArray
    val userNames: ArrayList<String>
    val uniqueUser: User
    val uniqueUsers: ArrayList<User>

    companion object
}

fun UserPage.Companion.getDestination(userId: String, isLoggedIn: Boolean, userIds: IntArray, userNames: ArrayList<String>, uniqueUser: User, uniqueUsers: ArrayList<User>, ): String {
    return "UserPage?" + 
        "userId=$userId," + 
        "isLoggedIn=$isLoggedIn," + 
        "userIds=${Uri.encode(gson.toJson(userIds))}," + 
        "userNames=${Uri.encode(gson.toJson(userNames))}," + 
        "uniqueUser=${Uri.encode(gson.toJson(uniqueUser))}," + 
        "uniqueUsers=${Uri.encode(gson.toJson(uniqueUsers))}" + 
        ""
}

// without companion object

@ComposeDestination
interface UserPage {
    val userId: String
    val isLoggedIn: Boolean
    val userIds: IntArray
    val userNames: ArrayList<String>
    val uniqueUser: User
    val uniqueUsers: ArrayList<User>
}

class UserPageDestination {
    companion object {
        fun getDestination(userId: String, isLoggedIn: Boolean, userIds: IntArray, userNames: ArrayList<String>, uniqueUser: User, uniqueUsers: ArrayList<User>, ): String {
            return "UserPage?" + 
                "userId=$userId," + 
                "isLoggedIn=$isLoggedIn," + 
                "userIds=${Uri.encode(gson.toJson(userIds))}," + 
                "userNames=${Uri.encode(gson.toJson(userNames))}," + 
                "uniqueUser=${Uri.encode(gson.toJson(uniqueUser))}," + 
                "uniqueUsers=${Uri.encode(gson.toJson(uniqueUsers))}" + 
                ""
        }
    }
}
```
* Adding support for default properties. To use a default property, you have to annotate that property with `@HasDefaultValue`. The annotation processor will pick these properties, and use the provider to set their values. Look at the following example-
```
@ComposeDestination
interface UserPage {
    @HasDefaultValue
    val userId: String
    val isLoggedIn: Boolean
    val userIds: IntArray
    val userNames: ArrayList<String>
    @HasDefaultValue
    val uniqueUser: User
    val uniqueUsers: ArrayList<User>
}
```
* To give the properties their default values, you have to provide some static or singleton instance The annotation processor will create an interface which will be extended by the object, to provide the necessary mapping of values. If you have provided a `companion object` as mentioned previously, you can annotate that with `@ArgumentProvider` and extend the necessary interface to provide the value. If not, you can declare any other object also. Look at the example below, `IUserPageProvider` is generated by the annotation processor-
```
@ComposeDestination
interface UserPage {
    @HasDefaultValue
    val userId: String
    val isLoggedIn: Boolean
    val userIds: IntArray
    val userNames: ArrayList<String>
    @HasDefaultValue
    val uniqueUser: User
    val uniqueUsers: ArrayList<User>

    @ArgumentProvider
    companion object : IUserPageProvider {
        override val userId: String
            get() = "sample-user-id"
        override val uniqueUser: User
            get() = User(id = -1, name = "default")
    }
}

// by providing a separate object

@ComposeDestination
interface UserPage {
    @HasDefaultValue
    val userId: String
    val isLoggedIn: Boolean
    val userIds: IntArray
    val userNames: ArrayList<String>
    @HasDefaultValue
    val uniqueUser: User
    val uniqueUsers: ArrayList<User>
}

@ArgumentProvider
object UserPageProvider : IUserPageProvider {
    override val userId: String
        get() = "sample-user-id"
    override val uniqueUser: User
        get() = User(id = -1, name = "default")
}
```

# 1.0.0
* Initial version, adding annotation processing for `ComposeDestination`. For details on how to use, checkout ReadMe.md

# 1.0.1
* Adding support for nullable properties